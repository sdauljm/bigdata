第一题:
1.按照队伍分组，年份排序
2.使用排名函数并按照队伍和年份与排名的差值分组
3.使用count进行筛选并对结果进行去重
select distinct(team) from 
      (select team,rank from 
	      (SELECT team,year,
		    (year-row_number() over (partition by team order by year)) 
		   as rank from test2.t1) 
       tmp group by team,rank 
       having count(*)=3) t2;

第二题:
波峰:比前后两天的数据都大即为波峰
波谷:比前后两天的数据都小即为波谷
1.使用LAG函数将前一天数据找出
2.使用LEAD函数将后一天的数据找出
3.通过使用case when 函数给来判断是波峰还是波谷
select id,time,price,
case 
       when price >p1 and price >p2 then '波峰'
       when  price <p1 and price <p2 then '波谷'
end futer
from (
	select id,time,price,LAG(price,1,price) over(partition by id order by time) p1,
			LEAD(price,1,price) over(partition by id order by time) p2 
	from t2
	 ) t3
where (price >p1 and price >p2)  or ( price <p1 and price <p2 );

第三题(1):
按照id分组计数即可
with tmp as (
select t.*,
unix_timestamp(t.dt, 'yyyy/MM/dd hh:mm') dt2
from t3 t
)
select id,
count(1) count,
(max(dt2) - min(dt2)) / 60 as timelen
from tmp
group by id

第三题(2):
1.通过lag函数对数据进行错位
2.计算出该行数据的时间与上一行数据的时间的差值
3.使用窗口函数进行求和，求和方式为第一行到当前行
4.对数据进行统计
with ta as (
select 
t.id,
t.dt,
lag(t.dt) over(partition by t.id order by t.dt) dt2
from t3 t
),
tb as (
select t.id,t.dt,t.dt2,
(unix_timestamp(t.dt , "YYYY/MM/dd hh:mm") - unix_timestamp(t.dt2 , "YYYY/MM/dd hh:mm"))/60 tl,
case when (unix_timestamp(t.dt , "YYYY/MM/dd hh:mm") - unix_timestamp(t.dt2 , "YYYY/MM/dd hh:mm"))/60 >= 30 then 1 else 0 end mark
from ta t
),
tc as (select 
t.id,
t.dt,
t.dt2,
t.tl,
sum(t.mark) over(partition by t.id order by t.dt rows BETWEEN unbounded preceding and current row) as mark
from tb t)
select t.id,
(unix_timestamp(max(t.dt) , "YYYY/MM/dd hh:mm") - unix_timestamp(min(t.dt), "YYYY/MM/dd hh:mm"))/60 tl,
count(1) count
from tc t 
group by t.id,t.mark
